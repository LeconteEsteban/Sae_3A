import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import FactorAnalysis
from sklearn.cluster import KMeans
import requests
from io import StringIO


# URL du fichier Google Sheets
url = 'https://docs.google.com/spreadsheets/d/1cWkVcuw_wTQxqTgJcRfCZTweSb06tzfHVbuAd73owNw/export?format=csv'

# Télécharger le fichier CSV
response = requests.get(url)

# Vérifier si la requête a réussi
if response.status_code == 200:
     # Convert the content to a string and use StringIO to handle it as a file-like object
    csv_data = StringIO(response.content.decode('utf-8'))

    # Read the CSV into a DataFrame with low_memory=False to avoid mixed dtype warnings
    df = pd.read_csv(csv_data, low_memory=False, usecols=range(25))

else:
    print(f"Erreur lors du téléchargement du fichier: {response.status_code}")

# URL du fichier Google Sheets
url = 'https://docs.google.com/spreadsheets/d/1cWkVcuw_wTQxqTgJcRfCZTweSb06tzfHVbuAd73owNw/export?format=csv'

# Télécharger le fichier CSV
response = requests.get(url)

# Vérifier si la requête a réussi
if response.status_code == 200:
     # Convert the content to a string and use StringIO to handle it as a file-like object
    csv_data = StringIO(response.content.decode('utf-8'))

    # Read the CSV into a DataFrame with low_memory=False to avoid mixed dtype warnings
    df_author = pd.read_csv(csv_data, low_memory=False, usecols=range(18))

else:
    print(f"Erreur lors du téléchargement du fichier: {response.status_code}")

# Retirer les lignes où 'year_published' est inférieur à 1500
df_year = df[df['year_published'] >= 1900]

# Calculer les quantiles basés sur les années
NbQuantiles = 4
# Calculer les quantiles et laisser qcut générer les intervalles comme labels
NbQuantiles = 4
df_year['year_group'] = pd.qcut(df_year['year_published'], q=NbQuantiles)

# Réorganiser les données pour le boxplot
df_melted = pd.melt(df_year, id_vars='year_group',  # Utilise 'year_group' ici
                    value_vars=['five_star_ratings', 'four_star_ratings',
                                'three_star_ratings', 'two_star_ratings',
                                'one_star_ratings'],
                    var_name='rating', value_name='value')

# Créer le boxplot avec Seaborn
plt.figure(figsize=(12, 6))
sns.boxplot(x='year_group', y='value', hue='rating', data=df_melted)

# Ajouter un titre et des étiquettes
plt.title("Box plot of ratings by year group")
plt.xlabel('Year Group (by Quartiles)')  # Étiquette de l'axe des x
plt.ylabel('Rating Values')              # Étiquette de l'axe des y

plt.legend(title='Rating Type')          # Ajouter une légende
plt.yscale('log')                        # Utiliser une échelle logarithmique si nécessaire
plt.show()                               # Afficher le graphique

# Calcul de la moyenne et de l'écart type
df_mean = df_author.groupby('author_average_rating')['book_average_rating'].mean()
df_std = df_author.groupby('author_average_rating')['book_average_rating'].std()

n = len(df_author)
ci = 1.96 * df_std / np.sqrt(n)  # Utiliser df_std pour le calcul de l'intervalle de confiance
x = df_mean.index
y = df_mean.values

plt.figure(figsize=(32, 8))  # Taille du plot

# Tracé de la moyenne et de l'intervalle de confiance
plt.plot(x, y, label='Mean average rating')
plt.fill_between(x, (y - ci), (y + ci), color='#ff2515', alpha=0.7, label='95% CI')


# Ajuster les labels des axes et le titre
plt.xlabel("author_average_rating", fontsize=14)
plt.ylabel("book_average_rating", fontsize=14)
plt.title("Plot of author_average_rating as a function of book_average_rating with 95% CI", fontsize=16)

plt.xticks(fontsize=12)
plt.yticks(fontsize=12)

plt.legend()
plt.show()
